#include <iostream>
#include <functional>
#include <random>
#include <time.h>
#include <math.h>
#include <fstream> 
#include <queue>
#include <bits/stdc++.h>
#include <complex.h>
#include <algorithm>    //For random_shuffle
using namespace std;

/*
struct sampleSet1D {
    string samplingStrategy;//"Pure Monte Carlo", "Stratified", etc
    int numTrials;//Number of runs for each lambda
    int numLambdas;//Number of values for lambda tested
    double** xValues;//X values generated by the sampling strategy
    //xValues is a numTrials x numLambdas array
};*/

const int primes[10] = {2,3,5,7,11,13,17,19,23,29};
const double epsilon = 0.00001;

//TODO: change
double standardDeviation = sqrt(0.05);
double mean = 0.5;

double sampleQuad(double x, double lambda) {
    return 600 * (x-lambda) * (x-lambda) + 1;
}

double groundTruthQuad(double lambda, double intervalStart, double intervalEnd) {
    //just for (x-lambda)^2 + 2 from 0 to 1
    //return 201 - 600 * lambda + 600 * lambda * lambda;
    return 200 * pow(intervalEnd - lambda, 3) + intervalEnd - 200 * pow(intervalStart - lambda, 3) - intervalStart;
}

double sampleStep(double x, double lambda) {
    return (double) 150 * (x > lambda);
}

double heaviside(double x, double lambda) {
    return x > lambda;
}

double groundTruthStep(double lambda, double intervalStart, double intervalEnd) {
    if (intervalEnd < lambda) {
        return 0;
    } else {
        return 150 * (intervalEnd-lambda);
    }
}

//Standard deviation (sigma) is 1
//Mean (mu) is lambda
//Returns the derivative of the gaussian w.r.t. its mean
double gaussianDerivativeWRTMean1D(double x, double lambda) {
    return exp(-0.5 * (x - lambda) * (x - lambda)) * (x - lambda) / sqrt(2 * M_PI);
}

//Standard deviation (sigma) is 1
//Mean (mu) is lambda
//Returns the integral from 0 to 1 of the derivative of the gaussian w.r.t. its mean
double groundTruthGaussianDerivativeWRTMean1D(double lambda, double intervalStart, double intervalEnd) {
    return -(exp(-0.5 * (intervalEnd - lambda) * (intervalEnd - lambda)) - exp(-0.5 * (intervalStart - lambda) * (intervalStart - lambda)))/sqrt(2 * M_PI);
}

//Standard deviation (sigma) is 1
//Mean (mu) is gausMean
//Discont. location is heavLambda
//Returns the derivative of the gaussian w.r.t. its mean
double gaussianDerivativeWRTMeanTimesStep1D(double x, double gausMean, double heavLambda) {
    return heaviside(x, heavLambda) * gaussianDerivativeWRTMean1D(x, gausMean);
}

//Standard deviation (sigma) is 1
//Mean (mu) is gausMean
//Discont. location is heavLambda
//Returns the integral from 0 to 1 of the derivative of the gaussian w.r.t. its mean
double groundTruthGaussianDerivativeWRTMeanTimesStep1D(double gausMean, double heavLambda, double intervalStart, double intervalEnd) {
    if (heavLambda > intervalEnd) {
        return 0;
    }
    if (heavLambda > intervalStart) {
        intervalStart = heavLambda;
    }
    return -(exp(-0.5 * (intervalEnd - gausMean) * (intervalEnd - gausMean)) - exp(-0.5 * (intervalStart - gausMean) * (intervalStart - gausMean)))/sqrt(2 * M_PI);
}

double disk(double x, double y) {
    return (double) (x*x + y*y < 2/M_PI);
}

double triangle(double x, double y) {
    return (double) (y > x);
}

double step2D(double x, double y) {
    return (double) (x < 1/M_PI);
}

double gaussian(double x, double y) {
    return exp(-x*x - y*y);
}

double bilinear(double x, double y) {
    return x*y;
}

//Temp. TODO: change
double gausWRTStd2D(double x, double y) {
    return (x*x + y*y) * exp(-(x*x + y*y));
}

//derivative of gaussian w.r.t. mean
//(specifically, derivative of exp(-((x-mux)^2 + y^2)) w.r.t. mux)
double gausWRTMean2D(double x, double y, double mux) {
    return 2 * (x - mux) * exp(-(x - mux) * (x-mux) - y * y);
}

double gausWRTMean2DGroundTruth(double a, double b, double c, double d, double mux) {
    return 0.5 * sqrt(M_PI) * (exp(-(a-mux)*(a-mux)) - exp(-(b-mux)*(b-mux))) * (erf(d) - erf(c));
}

//derivative of gaussian w.r.t. mean divided by gaussian. (Used when importance sampling)
//(specifically, derivative of exp(-((x-mux)^2 + y^2)) w.r.t. mux, divided by exp(-(x^2 + y^2)))
double gausWRTMeanImp2D(double x, double y, double mux) {
    return 2 * (x - mux) * exp(mux * (2*x - mux));
}

double gausWRTMeanImp2DGroundTruth(double a, double b, double c, double d, double mux) {
    if (mux == 0) {
        mux = 0.0000001;
    }
    return 0.5 * (d - c) * exp(-mux * mux) * (exp(2 * mux * b) * (2 * mux * b - 1 - 2 * mux * mux) - (2 * mux * a - 1 - 2 * mux * mux) * exp(2 * mux * a)) / (mux * mux);
}


//Temp for analytic MSE
double tempFoo(double x, double mux) {
    return exp(-(x - mux) * (x-mux)) * 2 * (x - mux);
}

double tempFooGroundTruth(double mux, double start, double end) {
    return 1 - (1/exp(1));
}

double radicalInverse(int base, int a) {
    //Could be optimized based on https://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/The_Halton_Sampler, but currently isn't
    int temp;
    double result = 0;
    double multBy = 1.0/base;
    while (a != 0) {
        temp = a % base;
        result += temp * multBy;
        //cout << (temp * multBy) << endl;
        multBy /= base;
        a /= base;
    }
    return result;
}

double* genHaltonSeq1D(int N, double a, double b, mt19937 & gen) {
    double* seqArr = new double[N];
    for (int i = 0; i < N; i++) {
        seqArr[i] = (b-a) * radicalInverse(2, i+1) + a;
    }
    return seqArr;
}

double* genHaltonSeqRot1D(int N, double a, double b, mt19937 & gen) {
    double* seqArr = new double[N];
    uniform_real_distribution<> dist3(0, 1);
    double offset = dist3(gen);
    for (int i = 0; i < N; i++) {
        seqArr[i] = (b-a) * fmod(radicalInverse(2, i+1) + offset, 1) + a;
    }
    return seqArr;
}

double* genHaltonSeqAntithetic1D(int N, double a, double b, mt19937 & gen) {
    double* seqArr = new double[N];
    for (int i = 0; i < N/2.0; i++) {
        seqArr[i] = (b-a) * radicalInverse(2, i+1) + a;
        seqArr[N - i - 1] = -(b-a) * radicalInverse(2, i+1) + b;
    }
    return seqArr;
}

//awkward to define and doesn't seem to help so leaving out for now
double* genHaltonSeqRotAntithetic1D(int N, double a, double b, mt19937 & gen) {
    double* seqArr = new double[N];
    uniform_real_distribution<> dist3(0, 1);
    double offset = dist3(gen);
    for (int i = 0; i < N/2.0; i++) {
        seqArr[i] = (b-a) * fmod(radicalInverse(2, i+1) + offset, 1) + a;
        seqArr[N - i - 1] = -(b-a) * fmod(radicalInverse(2, i+1) + offset, 1) + b;
    }
    return seqArr;
}

double** genHaltonSeq2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    double** seqArr = new double*[N];
    for (int i = 0; i < N; i++) {
        seqArr[i] = new double[2];
        seqArr[i][0] = (b-a) * radicalInverse(primes[0], i+1) + a;
        seqArr[i][1] = (d-c) * radicalInverse(primes[1], i+1) + c;
    }
    return seqArr;
}

double** genHaltonSeqRot2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    //uniform_real_distribution<> dist1(0, b-a);
    //uniform_real_distribution<> dist2(0, d-c);
    uniform_real_distribution<> dist3(0, 1);
    double** seqArr = new double*[N];
    double offset = dist3(gen);
    //double rot1 = dist1(gen);
    //double rot2 = dist2(gen);
    for (int i = 0; i < N; i++) {
        seqArr[i] = new double[2];
        seqArr[i][0] = (b-a) * (radicalInverse(primes[0], i+1) + offset) + a;
        seqArr[i][1] = (d-c) * (radicalInverse(primes[1], i+1) + offset) + c;
        if (seqArr[i][0] > b) {
            seqArr[i][0] -= b-a;
        }
        if (seqArr[i][1] > d) {
            seqArr[i][1] -= d-c;
        }
    }
    return seqArr;
}

//new
double** genHaltonSeqAntithetic2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    double** seqArr = new double*[N];
    for (int i = 0; i < N/2.0; i++) {
        seqArr[i] = new double[2];
        seqArr[N - i - 1] = new double[2];
        seqArr[i][0] = (b-a) * radicalInverse(primes[0], i+1) + a;
        seqArr[i][1] = (d-c) * radicalInverse(primes[1], i+1) + c;
        seqArr[N - i - 1][0] = -(b-a) * radicalInverse(primes[0], i+1) + b;
        seqArr[N - i - 1][1] = -(d-c) * radicalInverse(primes[1], i+1) + d;
    }
    return seqArr;
}

double* genPureMonteCarlo1D(int N, double a, double b, mt19937 & gen) {
    uniform_real_distribution<> dist(a, b);
    double* seqArr = new double[N];
    for (int i = 0; i < N; i++) {
        seqArr[i] = dist(gen);
    }
    return seqArr;
}

double** genPureMonteCarlo2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    uniform_real_distribution<> distX(a, b);
    uniform_real_distribution<> distY(c, d);
    double** seqArr = new double*[N];
    for (int i = 0; i < N; i++) {
        seqArr[i] = new double[2];
        seqArr[i][0] = distX(gen);
        seqArr[i][1] = distY(gen);
    }
    return seqArr;
}

double* genAntitheticMonteCarlo1D(int N, double a, double b, mt19937 & gen) {
    uniform_real_distribution<> dist(a, b);
    double* seqArr = new double[N];
    for (int i = 0; i < N/2.0; i++) {
        seqArr[i] = dist(gen);
        seqArr[N-i-1] = b-(seqArr[i]-a);
    }
    if (N == 10) {
        for (int i = 0; i < N-1; i++) {
            //cout << seqArr[i] << ",";
        }
        //cout << seqArr[N-1] << endl;
    }
    return seqArr;
}

double** genAntitheticMonteCarlo2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    uniform_real_distribution<> distX(a, b);
    uniform_real_distribution<> distY(c, d);
    double** seqArr = new double*[N];
    for (int i = 0; i < N; i++)
    	seqArr[i] = new double[2];
    for (int i = 0; i < N/2.0; i++) {
        seqArr[i] = new double[2];
        seqArr[i][0] = distX(gen);
        seqArr[i][1] = distY(gen);
        seqArr[N-i-1][0] = b-(seqArr[i][0]-a);
        seqArr[N-i-1][1] = d-(seqArr[i][1]-c);
    }
    return seqArr;
}

double* genUniform1D(int N, double a, double b, mt19937 & gen) {
    double strataSize = (b-a)/N;
    double* seqArr = new double[N];
    for (int i = 0; i < N; i++) {
        seqArr[i] = a + strataSize/2 + i * strataSize;
    }
    if (N == 10) {
        for (int i = 0; i < N-1; i++) {
            //cout << seqArr[i] << ",";
        }
        //cout << seqArr[N-1] << endl;
    }
    return seqArr;
}

double* genUniformJitter1D(int N, double a, double b, mt19937 & gen) {
    uniform_real_distribution<> dist3(0, 1);
    double offset = dist3(gen);
    double strataSize = (b-a)/N;
    double* seqArr = new double[N];
    for (int i = 0; i < N; i++) {
        seqArr[i] = a + fmod(strataSize/2 + (i + offset) * strataSize, b-a);
    }
    return seqArr;
}

double** genUniform2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    int dimN = sqrt(N);
    double strataSizeX = (b-a)/dimN;
    double strataSizeY = (d-c)/dimN;
    double** seqArr = new double*[dimN * dimN];
    for (int i = 0; i < dimN; i++) {
        for (int j = 0; j < dimN; j++) {
            seqArr[i * dimN + j] = new double[dimN * dimN];
            seqArr[i * dimN + j][0] = a + (i + 0.5) * strataSizeX;
            seqArr[i * dimN + j][1] = c + (j + 0.5) * strataSizeY;
        }
    }
    return seqArr;
}

//new
double** genUniformJitter2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    int dimN = sqrt(N);
    double strataSizeX = (b-a)/dimN;
    double strataSizeY = (d-c)/dimN;
    double** seqArr = new double*[dimN * dimN];
    uniform_real_distribution<> dist3(0, 1);
    double offsetX = dist3(gen);
    double offsetY = dist3(gen);
    for (int i = 0; i < dimN; i++) {
        for (int j = 0; j < dimN; j++) {
            seqArr[i * dimN + j] = new double[dimN * dimN];//TODO: understand
            seqArr[i * dimN + j][0] = a + (i + offsetX) * strataSizeX;
            if (seqArr[i * dimN + j][0] > b) {
                cout << "What????\n";
            }
            seqArr[i * dimN + j][1] = c + (j + offsetY) * strataSizeY;
        }
    }
    return seqArr;
}

double* genStratified1D(int N, double a, double b, mt19937 & gen) {
    uniform_real_distribution<> dist(0, 1);
    double strataSize = (b-a)/N;
    double* seqArr = new double[N];
    for (int i = 0; i < N; i++) {
        seqArr[i] = a + strataSize * (i + dist(gen));
    }
    return seqArr;
}

//antithetic within strata, as in the Error analysis of estimators that use combinations of stochastic sampling strategies for direct illumination
double* genStratifiedAntithetic1D(int N, double a, double b, mt19937 & gen) {
    uniform_real_distribution<> dist(0, 1);
    double strataSize = 2*(b-a)/N;
    float strataOffset;
    double* seqArr = new double[N];
    for (int i = 0; i < N/2.0; i++) {
        strataOffset = dist(gen);
        seqArr[i] = a + strataSize * (i + strataOffset);
        seqArr[N - i - 1] = a + strataSize * (i + 1 - strataOffset);
    }
    return seqArr;
}

//antithetic globally
double* genStratifiedAntithetic1D2(int N, double a, double b, mt19937 & gen) {
    uniform_real_distribution<> dist(0, 1);
    double strataSize = (b-a)/N;
    float strataOffset;
    double* seqArr = new double[N];
    for (int i = 0; i < N/2.0; i++) {
        strataOffset = dist(gen);
        seqArr[i] = a + strataSize * (i + strataOffset);
        seqArr[N - i - 1] = b - strataSize * (i + strataOffset);
    }
    return seqArr;
}

//antithetic locally and globally
double* genStratifiedAntithetic1D3(int N, double a, double b, mt19937 & gen) {
    uniform_real_distribution<> dist(0, 1);
    double strataSize = 2*(b-a)/N;
    float strataOffset;
    double* seqArr = new double[N];
    for (int i = 0; i < N/4.0; i++) {
        strataOffset = dist(gen);
        seqArr[i] = a + strataSize * (i + strataOffset);
        seqArr[(int) (N/2.0 - i - 1)] = a + strataSize * (i + 1 - strataOffset);
        seqArr[(int) (N - i - 1)] = b - (seqArr[i] - a);
        seqArr[(int) (N - (N/2.0 - i - 1) - 1)] = b - (seqArr[(int) (N/2.0 - i - 1)] - a);
    }
    return seqArr;
}

double** genStratified2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    uniform_real_distribution<> dist(0, 1);
    int dimN = sqrt(N);
    double strataSizeX = (b-a)/dimN;
    double strataSizeY = (d-c)/dimN;
    double** seqArr = new double*[dimN * dimN];
    for (int i = 0; i < dimN; i++) {
        for (int j = 0; j < dimN; j++) {
            seqArr[i * dimN + j] = new double[2];
            seqArr[i * dimN + j][0] = a + strataSizeX * (i + dist(gen));
            seqArr[i * dimN + j][1] = c + strataSizeY * (j + dist(gen));
        }
    }
    return seqArr;
}

//new
//locally antithetic
double** genStratifiedAntithetic2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    uniform_real_distribution<> dist(0, 1);
    int dimN = sqrt(N/2);
    double** seqArr = new double*[dimN * dimN * 2];
    double strataSizeX = (b-a)/dimN;
    double strataSizeY = (d-c)/dimN;
    float strataOffset;
    for (int i = 0; i < dimN; i++) {
        for (int j = 0; j < dimN; j++) {
            seqArr[i * dimN + j] = new double[2];
            seqArr[dimN * dimN * 2 - (i * dimN + j) - 1] = new double[2];
            strataOffset = dist(gen);
            seqArr[i * dimN + j][0] = a + strataSizeX * (i + strataOffset);
            seqArr[dimN * dimN * 2 - (i * dimN + j) - 1][0] = a + strataSizeX * (i + 1 - strataOffset);
            strataOffset = dist(gen);
            seqArr[i * dimN + j][1] = c + strataSizeY * (j + strataOffset);
            seqArr[dimN * dimN * 2 - (i * dimN + j) - 1][1] = c + strataSizeY * (j + 1 - strataOffset);
        }
    }
    return seqArr;
}

//new
//globally antithetic
double** genStratifiedAntithetic2D2(int N, double a, double b, double c, double d, mt19937 & gen) {
    uniform_real_distribution<> dist(0, 1);
    int dimN = sqrt(N);
    double strataSizeX = (b-a)/dimN;
    double strataSizeY = (d-c)/dimN;
    double** seqArr = new double*[dimN * dimN];
    float strataOffset;
    for (int i = 0; i < dimN; i++) {
        for (int j = i; j < dimN; j++) {
            seqArr[i * dimN + j] = new double[2];
            seqArr[j * dimN + i] = new double[2];
            strataOffset = dist(gen);
            seqArr[i * dimN + j][0] = a + strataSizeX * (i + strataOffset);
            seqArr[j * dimN + i][0] = b - strataSizeX * (i + strataOffset);
            strataOffset = dist(gen);
            seqArr[i * dimN + j][1] = c + strataSizeY * (j + strataOffset);
            seqArr[j * dimN + i][1] = d - strataSizeY * (j + strataOffset);
        }
    }
    return seqArr;
}

//new
//locally and globally antithetic
double** genStratifiedAntithetic2D3(int N, double a, double b, double c, double d, mt19937 & gen) {
    uniform_real_distribution<> dist(0, 1);
    int dimN = sqrt(N/2);
    double** seqArr = new double*[dimN * dimN * 2];
    double strataSizeX = (b-a)/dimN;
    double strataSizeY = (d-c)/dimN;
    float strataOffset;
    for (int i = 0; i < dimN; i++) {
        for (int j = i; j < dimN; j++) {
            seqArr[i * dimN + j] = new double[2];
            seqArr[dimN * dimN * 2 - (i * dimN + j) - 1] = new double[2];
            seqArr[j * dimN + i] = new double[2];
            seqArr[dimN * dimN * 2 - (j * dimN + i) - 1] = new double[2];

            strataOffset = dist(gen);
            seqArr[i * dimN + j][0] = a + strataSizeX * (i + strataOffset);
            seqArr[dimN * dimN * 2 - (i * dimN + j) - 1][0] = a + strataSizeX * (i + 1 - strataOffset);
            seqArr[j * dimN + i][0] = b - strataSizeX * (i + strataOffset);
            seqArr[dimN * dimN * 2 - (j * dimN + i) - 1][0] = b - strataSizeX * (i + 1 - strataOffset);

            strataOffset = dist(gen);
            seqArr[i * dimN + j][1] = c + strataSizeY * (j + strataOffset);
            seqArr[dimN * dimN * 2 - (i * dimN + j) - 1][1] = c + strataSizeY * (j + 1 - strataOffset);
            seqArr[j * dimN + i][1] = d - strataSizeY * (j + strataOffset);
            seqArr[dimN * dimN * 2 - (j * dimN + i) - 1][1] = d - strataSizeY * (j + 1 - strataOffset);
        }
    }
    return seqArr;
}

double** genNRooks2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    //somewhat based on pseudo code from https://cs.dartmouth.edu/~wjarosz/publications/subr16fourier.html
    uniform_real_distribution<> dist(0,1);
    double strataSizeX = (b-a)/N;
    double strataSizeY = (d-c)/N;

    vector<double> sampleXs(N,0);
    vector<double> sampleYs(N,0);
    for (int i = 0; i < N; i++) {
        sampleXs[i] = a + (i + dist(gen)) * strataSizeX;
        sampleYs[i] = c + (i + dist(gen)) * strataSizeY;
    }
    random_shuffle(sampleXs.begin(),sampleXs.end());//Shuffle the sample x coordinates
    random_shuffle(sampleYs.begin(),sampleYs.end());//Shuffle the sample y coordinates

    double** seqArr = new double*[N];
    for (int i = 0; i < N; i++) {
        seqArr[i] = new double[2];
        seqArr[i][0] = sampleXs[i];
        seqArr[i][1] = sampleYs[i];
    }
    return seqArr;
}

double** genMultiJitter2D(int N, double a, double b, double c, double d, mt19937 & gen) {
    //somewhat based on pseudo code from https://cs.dartmouth.edu/~wjarosz/publications/subr16fourier.html
    N = sqrt(N);//Code written for N*N samples, so take square root to adjust to that
    uniform_real_distribution<> dist(0,1);
    double estimate = 0;
    double strataSizeX = (b-a)/(N*N);
    double strataSizeY = (d-c)/(N*N);
    //The outer vector contains the columns
    //Each inner vector contains the x values of each of the points in the columns
    vector<vector<double>> sampleXs(N,vector<double>(N,0));
    //The outer vector contains the rows
    //Each inner vector contains the y values of each of the points in the rows
    vector<vector<double>> sampleYs(N,vector<double>(N,0));

    for (int i = 0; i < N; i++) {
        //column i
        //Also simultaneously row i
        for (int j = 0; j < N; j++) {
            //point j in column i
            //Also simultaneously point j in row i
            sampleXs[i][j] = a + (i*N + j + dist(gen)) * strataSizeX;
            sampleYs[i][j] = c + (i*N + j + dist(gen)) * strataSizeY;
        }
    }

    for (int i = 0; i < N; i++) {
        random_shuffle(sampleXs[i].begin(),sampleXs[i].end());//Shuffle the sample x coordinates
        random_shuffle(sampleYs[i].begin(),sampleYs[i].end());//Shuffle the sample y coordinates
    }

    double** seqArr = new double*[N*N];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            seqArr[i * N + j] = new double[2];
            seqArr[i * N + j][0] = sampleXs[i][j];
            seqArr[i * N + j][1] = sampleYs[j][i];
        }
    }

    return seqArr;
}

double estimateIntegral1D(double a, double b, int N, double lambda, function<double (double,double)> F, function<double* (int, double, double, mt19937 &)> sampleGen, mt19937 & gen) {
    double* samplePoints = sampleGen(N, a, b, gen);
    double estimate = 0;
    double temp;
    for (int i = 0; i < N; i++) {
        temp = F(samplePoints[i],lambda);
        estimate += temp;
    }
    estimate /= N;
    estimate *= (b-a);
    delete samplePoints;
    return estimate;
}

//Simpson's 1/3 rule (quadratic interpolation)
double estimateIntegralSimpsons1DOld(double a, double b, int N, double lambda, function<double (double,double)> F, mt19937 & gen) {
    if (N % 2 == 0) {
        N--;//N needs to be odd
    }
    double est = 0;
    double sectionSize = (b-a) / ((N-1) / 2.0);
    for (int i = 0; i < (N-1)/2.0; i++) {
        double start = a + i * sectionSize;
        double end = a + (i + 1) * sectionSize;
        double mid = a + (i + 0.5) * sectionSize;
        est += (F(start,lambda) + 4 * F(mid,lambda) + F(end,lambda)) * sectionSize / 6.0;
    }
    return est;
}

//Simpson's 1/3 rule (quadratic interpolation)
double estimateIntegralSimpsons1D(double a, double b, int N, double lambda, function<double (double,double)> F, mt19937 & gen) {
    if (N % 2 == 0) {
        N--;//N needs to be odd
    }
    double est = 0;
    double stepSize = (b-a) / (N-1);
    double xVal;
    for (int i = 0; i < N; i++) {
        xVal = i * stepSize + a;
        if (i == 0 || i == N-1) {
            est += F(xVal,lambda);
        } else if (i % 2 == 0) {
            est += 2 * F(xVal,lambda);
        } else {
            est += 4 * F(xVal,lambda);
        }
        //cout << xVal << endl;
        //cout << xVal << ", " << F(xVal,lambda) << endl;
    }
    est *= stepSize / 3.0; 
    return est;
}

//Simpson's 1/3 rule (quadratic interpolation)
double estimateIntegralSimpsons2Lambdas1DOld(double a, double b, int N, double lambda1, double lambda2, function<double (double,double,double)> F, mt19937 & gen) {
    if (N % 2 == 0) {
        N--;//N needs to be odd
    }
    double est = 0;
    double sectionSize = (b-a) / ((N-1) / 2.0);
    for (int i = 0; i < (N-1)/2.0; i++) {
        double start = a + i * sectionSize;
        double end = a + (i + 1) * sectionSize;
        double mid = a + (i + 0.5) * sectionSize;
        est += (F(start,lambda1,lambda2) + 4 * F(mid,lambda1,lambda2) + F(end,lambda1,lambda2)) * sectionSize / 6.0;
    }
    return est;
}

//Simpson's 1/3 rule (quadratic interpolation)
double estimateIntegralSimpsons2Lambdas1D(double a, double b, int N, double lambda1, double lambda2, function<double (double,double,double)> F, mt19937 & gen) {
    if (N % 2 == 0) {
        N--;//N needs to be odd
    }
    double est = 0;
    double stepSize = (b-a) / (N-1);
    double xVal;
    for (int i = 0; i < N; i++) {
        xVal = i * stepSize + a;
        if (i == 0 || i == N-1) {
            est += F(xVal,lambda1,lambda2);
        } else if (i % 2 == 0) {
            est += 2 * F(xVal,lambda1,lambda2);
        } else {
            est += 4 * F(xVal,lambda1,lambda2);
        }
    }
    est *= stepSize / 3.0; 
    return est;
}

//Poly Approx start

double determinant(double a, double b, double c, double d, double e, double f, double g, double h, double i) {
    return a * (e*i - h*f) - b * (d*i - g*f) + c * (d*h - g*e);
}

int compareArr(const void * arr1, const void * arr2) {
    return (((double**) arr1)[0][0] > ((double**) arr2)[0][0]) - (((double**) arr1)[0][0] < ((double**) arr2)[0][0]);
}

//Returns the integral from x=start to x=end of f(x) = ax^2 + bx + c
double polyInt(double start, double end, double a, double b, double c) {
    a /= 3;
    b /= 2;
    double integral = 0;
    integral += a * end * end * end;
    integral += b * end * end;
    integral += c * end;
    integral -= a * start * start * start;
    integral -= b * start * start;
    integral -= c * start;
    return integral;
}

double miniSimpsons(double intervalStart, double intervalEnd, function<double (double, double)> testFunc, double lambda) {
    return (testFunc(intervalStart, lambda) + 4 * testFunc((intervalStart + intervalEnd) / 2.0, lambda) + testFunc(intervalEnd, lambda)) * (intervalEnd - intervalStart) / 6.0;
}

double miniTrapezoidal(double intervalStart, double intervalEnd, function<double (double, double)> testFunc, double lambda) {
    return (intervalEnd - intervalStart) * (testFunc(intervalEnd, lambda) + testFunc(intervalStart, lambda)) / 2.0;
}

double estimateError(double intervalStart, double intervalEnd, function<double (double, double)> testFunc, double lambda) {
    return abs(miniSimpsons(intervalStart, intervalEnd, testFunc, lambda) - miniTrapezoidal(intervalStart, intervalEnd, testFunc, lambda)) + epsilon * (intervalEnd - intervalStart);
}

void getCoefs(double x1, double x3, function<double (double, double)> testFunc, double* coefs, double lambda) {
    //quadratic approximation
    double x2 = (x1 + x3) / 2.0;
    double y1 = testFunc(x1, lambda);
    double y2 = testFunc(x2, lambda);
    double y3 = testFunc(x3, lambda);

    double D = determinant(x1*x1, x1, 1, x2*x2, x2, 1, x3*x3, x3, 1);
    double Da = determinant(y1, x1, 1, y2, x2, 1, y3, x3, 1);
    double Db = determinant(x1*x1, y1, 1, x2*x2, y2, 1, x3*x3, y3, 1);
    double Dc = determinant(x1*x1, x1, y1, x2*x2, x2, y2, x3*x3, x3, y3);

    double a;
    double b;
    double c;
    if (D == 0) {
        //Just do a constant line
        a = 0;
        b = 0;
        c = y2;
    } else {
        a = Da / D;
        b = Db / D;
        c = Dc / D;
    }

    if (isinf(a)) {
        cout << "What????" << endl;
    }
    coefs[0] = a;
    coefs[1] = b;
    coefs[2] = c;
}

double** splitRegions(function<double (double, double)> testFunc, int regionsBudget, double lambda, double a, double b) {
    double** regions = new double*[regionsBudget];
    for (int i = 0; i < regionsBudget; i++) {
        regions[i] = new double[5];
    }
    int numRegions = 1;
    tuple<double, double, double> curr;
    priority_queue<tuple<double, double, double>> myHeap;
    //Each tuple has error estimate, startX, stopX
    myHeap.push(tuple<double, double, double>(estimateError(a, b, testFunc, lambda),a,b));
    double start, end, mid;
    while (numRegions < regionsBudget) {
        curr = myHeap.top();
        start = get<1>(curr);
        end = get<2>(curr);
        mid = (start + end) / 2;
        myHeap.pop();
        myHeap.push(tuple<double, double, double>(estimateError(start, mid, testFunc, lambda), start, mid));
        myHeap.push(tuple<double, double, double>(estimateError(mid, end, testFunc, lambda), mid, end));
        numRegions++;
    }
    for (int i = 0; i < regionsBudget; i++) {
        curr = myHeap.top();
        regions[i][0] = get<1>(curr);
        regions[i][1] = get<2>(curr);
        myHeap.pop();
        getCoefs(regions[i][0], regions[i][1], testFunc, &regions[i][2], lambda);
    }
    qsort(regions, regionsBudget, sizeof(regions[0]), compareArr);
    return regions;
}

double** splitRegionsEvenly(function<double (double, double)> testFunc, int regionsBudget, double lambda, double a, double b) {
    double** regions = new double*[regionsBudget];
    double regionSize = (b-a) / regionsBudget;
    for (int i = 0; i < regionsBudget; i++) {
        regions[i] = new double[5];
        regions[i][0] = i * regionSize + a;
        regions[i][1] = (i + 1) * regionSize + a;
        getCoefs(regions[i][0], regions[i][1], testFunc, &regions[i][2], lambda);
    }
    return regions;
}

double polyApproxEst(double** regions, double regionsBudget) {
    double estimate = 0;
    for (int i = 0; i < regionsBudget; i++) {
        estimate += polyInt(regions[i][0], regions[i][1], regions[i][2], regions[i][3], regions[i][4]);
        if (isnan(estimate) && regionsBudget == 134) {
            cout << "Estimate is no longer a number!\n";
            cout << regions[i][0] << ", " << regions[i][1] << ", " << regions[i][2] << ", " << regions[i][3] << ", " << regions[i][4] << endl;
        }
    }
    return estimate;
}

double polyApprox(double x, int regionsBudget, double** regions) {
    int low = 0;
    int high = regionsBudget;
    int curr = (low + high) / 2;
    while (regions[curr][0] > x || regions[curr][1] < x) {
        if (regions[curr][0] > x) {
            high = curr;
            curr = (low + high) / 2;
        } else if (regions[curr][1] < x) {
            low = curr;
            curr = (low + high) / 2;
        }
    }
    return regions[curr][2] * x * x + regions[curr][3] * x + regions[curr][4];
}

double residual(double x, double lambda, int regionsBudget, double** regions, function<double (double,double)> testFunc) {
    return testFunc(x,lambda) - polyApprox(x,regionsBudget,regions);
}

double estimateIntegralPolyApprox(double a, double b, int N, double lambda, function<double (double, double)> F, mt19937 & gen) {
    int regionsBudget = (N-1)/2;
    double** myRegions = splitRegionsEvenly(F, regionsBudget, lambda, a, b);
    double result = polyApproxEst(myRegions, regionsBudget);
    delete myRegions;
    return result;
}

double estimateIntegralPolyApproxControlVariate(double a, double b, int N, double lambda, function<double (double, double)> F, mt19937 & gen) {
    int regionsBudget = (N/2-1)/2;
    double** myRegions = splitRegionsEvenly(F, regionsBudget, lambda, a, b);
    double est = 0;
    uniform_real_distribution<> dist(0, 1);
    for (int i = 0; i < N/2; i++) {
        est += residual(dist(gen),lambda,regionsBudget,myRegions,F);
    }
    est /= N/2;
    est += polyApproxEst(myRegions,regionsBudget);
    delete myRegions;
    return est;
}

double estimateIntegralAdapPolyApprox(double a, double b, int N, double lambda, function<double (double, double)> F, mt19937 & gen) {
    int regionsBudget = (N-1)/2;
    double** myRegions = splitRegions(F, regionsBudget, lambda, a, b);
    double result = polyApproxEst(myRegions, regionsBudget);
    delete myRegions;
    return result;
}

double estimateIntegralAdapPolyApproxControlVariate(double a, double b, int N, double lambda, function<double (double, double)> F, mt19937 & gen) {
    int regionsBudget = (N/2-1)/2;
    double** myRegions = splitRegions(F, regionsBudget, lambda, a, b);
    double est = 0;
    uniform_real_distribution<> dist(0, 1);
    for (int i = 0; i < N/2; i++) {
        est += residual(dist(gen),lambda,regionsBudget,myRegions,F);
    }
    est /= N/2;
    est += polyApproxEst(myRegions,regionsBudget);
    delete myRegions;
    return est;
}

double miniSimpsons2Lambdas(double intervalStart, double intervalEnd, function<double (double, double, double)> testFunc, double lambda1, double lambda2) {
    return (testFunc(intervalStart, lambda1, lambda2) + 4 * testFunc((intervalStart + intervalEnd) / 2.0, lambda1, lambda2) + testFunc(intervalEnd, lambda1, lambda2)) * (intervalEnd - intervalStart) / 6.0;
}

double miniTrapezoidal2Lambdas(double intervalStart, double intervalEnd, function<double (double, double, double)> testFunc, double lambda1, double lambda2) {
    return (intervalEnd - intervalStart) * (testFunc(intervalEnd, lambda1, lambda2) + testFunc(intervalStart, lambda1, lambda2)) / 2.0;
}

double estimateError2Lambdas(double intervalStart, double intervalEnd, function<double (double, double, double)> testFunc, double lambda1, double lambda2) {
    return abs(miniSimpsons2Lambdas(intervalStart, intervalEnd, testFunc, lambda1, lambda2) - miniTrapezoidal2Lambdas(intervalStart, intervalEnd, testFunc, lambda1, lambda2)) + epsilon * (intervalEnd - intervalStart);
}

void getCoefs2Lambdas(double x1, double x3, function<double (double, double, double)> testFunc, double* coefs, double lambda1, double lambda2) {
    //quadratic approximation
    double x2 = (x1 + x3) / 2.0;
    double y1 = testFunc(x1, lambda1, lambda2);
    double y2 = testFunc(x2, lambda1, lambda2);
    double y3 = testFunc(x3, lambda1, lambda2);

    double D = determinant(x1*x1, x1, 1, x2*x2, x2, 1, x3*x3, x3, 1);
    double Da = determinant(y1, x1, 1, y2, x2, 1, y3, x3, 1);
    double Db = determinant(x1*x1, y1, 1, x2*x2, y2, 1, x3*x3, y3, 1);
    double Dc = determinant(x1*x1, x1, y1, x2*x2, x2, y2, x3*x3, x3, y3);

    double a;
    double b;
    double c;
    if (D == 0) {
        //Just do a constant line
        a = 0;
        b = 0;
        c = y2;
    } else {
        a = Da / D;
        b = Db / D;
        c = Dc / D;
    }

    if (isinf(a)) {
        cout << "What????" << endl;
    }
    coefs[0] = a;
    coefs[1] = b;
    coefs[2] = c;
}

double** splitRegions2Lambdas(function<double (double, double, double)> testFunc, int regionsBudget, double lambda1, double lambda2, double a, double b) {
    double** regions = new double*[regionsBudget];
    for (int i = 0; i < regionsBudget; i++) {
        regions[i] = new double[5];
    }
    int numRegions = 1;
    tuple<double, double, double> curr;
    priority_queue<tuple<double, double, double>> myHeap;
    //Each tuple has error estimate, startX, stopX
    myHeap.push(tuple<double, double, double>(estimateError2Lambdas(a, b, testFunc, lambda1, lambda2),a,b));
    double start, end, mid;
    while (numRegions < regionsBudget) {
        curr = myHeap.top();
        start = get<1>(curr);
        end = get<2>(curr);
        mid = (start + end) / 2;
        myHeap.pop();
        myHeap.push(tuple<double, double, double>(estimateError2Lambdas(start, mid, testFunc, lambda1, lambda2), start, mid));
        myHeap.push(tuple<double, double, double>(estimateError2Lambdas(mid, end, testFunc, lambda1, lambda2), mid, end));
        numRegions++;
    }
    for (int i = 0; i < regionsBudget; i++) {
        curr = myHeap.top();
        regions[i][0] = get<1>(curr);
        regions[i][1] = get<2>(curr);
        myHeap.pop();
        getCoefs2Lambdas(regions[i][0], regions[i][1], testFunc, &regions[i][2], lambda1, lambda2);
    }
    qsort(regions, regionsBudget, sizeof(regions[0]), compareArr);
    return regions;
}

double** splitRegionsEvenly2Lambdas(function<double (double, double, double)> testFunc, int regionsBudget, double lambda1, double lambda2, double a, double b) {
    double** regions = new double*[regionsBudget];
    double regionSize = (b-a) / regionsBudget;
    for (int i = 0; i < regionsBudget; i++) {
        regions[i] = new double[5];
        regions[i][0] = i * regionSize + a;
        regions[i][1] = (i + 1) * regionSize + a;
        getCoefs2Lambdas(regions[i][0], regions[i][1], testFunc, &regions[i][2], lambda1, lambda2);
    }
    return regions;
}

double residual2Lambdas(double x, double lambda1, double lambda2, int regionsBudget, double** regions, function<double (double,double,double)> testFunc) {
    return testFunc(x,lambda1,lambda2) - polyApprox(x,regionsBudget,regions);
}

double estimateIntegralPolyApprox2Lambdas(double a, double b, int N, double lambda1, double lambda2, function<double (double, double, double)> F, mt19937 & gen) {
    int regionsBudget = (N-1)/2;
    double** myRegions = splitRegionsEvenly2Lambdas(F, regionsBudget, lambda1, lambda2, a, b);
    /*for (int i = 0; i < regionsBudget; i++) {
        cout << "[";
        for (int j = 0; j < 4; j++) {
            cout << myRegions[i][j] << ", ";
        }
        cout << myRegions[i][4];
        cout << "]," << endl;
    }*/
    //cout << regionsBudget << endl;
    double result = polyApproxEst(myRegions, regionsBudget);
    delete myRegions;
    return result;
}

double estimateIntegralPolyApproxControlVariate2Lambdas(double a, double b, int N, double lambda1, double lambda2, function<double (double, double, double)> F, mt19937 & gen) {
    int regionsBudget = (N/2-1)/2;
    double** myRegions = splitRegionsEvenly2Lambdas(F, regionsBudget, lambda1, lambda2, a, b);
    double est = 0;
    uniform_real_distribution<> dist(0, 1);
    for (int i = 0; i < N/2; i++) {
        est += residual2Lambdas(dist(gen),lambda1,lambda2,regionsBudget,myRegions,F);
    }
    est /= N/2;
    est += polyApproxEst(myRegions,regionsBudget);
    delete myRegions;
    return est;
}

double estimateIntegralAdapPolyApprox2Lambdas(double a, double b, int N, double lambda1, double lambda2, function<double (double, double, double)> F, mt19937 & gen) {
    int regionsBudget = (N-1)/2;
    double** myRegions = splitRegions2Lambdas(F, regionsBudget, lambda1, lambda2, a, b);
    double result = polyApproxEst(myRegions, regionsBudget);
    delete myRegions;
    return result;
}

double estimateIntegralAdapPolyApproxControlVariate2Lambdas(double a, double b, int N, double lambda1, double lambda2, function<double (double, double, double)> F, mt19937 & gen) {
    int regionsBudget = (N/2-1)/2;
    double** myRegions = splitRegions2Lambdas(F, regionsBudget, lambda1, lambda2, a, b);
    double est = 0;
    uniform_real_distribution<> dist(0, 1);
    for (int i = 0; i < N/2; i++) {
        est += residual2Lambdas(dist(gen),lambda1,lambda2,regionsBudget,myRegions,F);
    }
    est /= N/2;
    est += polyApproxEst(myRegions,regionsBudget);
    delete myRegions;
    return est;
}

//Poly Approx end

double estimateIntegral2Lambdas1D(double a, double b, int N, double lambda1, double lambda2, function<double (double,double,double)> F, function<double* (int, double, double, mt19937 &)> sampleGen, mt19937 & gen) {
    double* samplePoints = sampleGen(N, a, b, gen);
    double estimate = 0;
    double temp;
    for (int i = 0; i < N; i++) {
        temp = F(samplePoints[i],lambda1,lambda2);
        estimate += temp;
    }
    estimate /= N;
    estimate *= (b-a);
    delete samplePoints;
    return estimate;
}

double estimateIntegral2D(double a, double b, double c, double d, int N, function<double (double,double)> F, function<double** (int, double, double, double, double, mt19937 &)> sampleGen, mt19937 & gen) {
    double** samplePoints = sampleGen(N, a, b, c, d, gen);
    double estimate = 0;
    double temp;
    for (int i = 0; i < N; i++) {
        temp = F(samplePoints[i][0],samplePoints[i][1]);
        estimate += temp;
    }
    estimate /= N;
    estimate *= (b-a);
    for (int i = 0; i < N; i++) {
        delete samplePoints[i];
    }
    delete samplePoints;
    return estimate;
}

double estimateIntegralLambda2D(double a, double b, double c, double d, int N, double lambda, function<double (double,double,double)> F, function<double** (int, double, double, double, double, mt19937 &)> sampleGen, mt19937 & gen) {
    double** samplePoints = sampleGen(N, a, b, c, d, gen);
    double estimate = 0;
    double temp;
    for (int i = 0; i < N; i++) {
        temp = F(samplePoints[i][0],samplePoints[i][1],lambda);
        estimate += temp;
    }
    estimate /= N;
    estimate *= (b-a);
    for (int i = 0; i < N; i++) {
        delete samplePoints[i];
    }
    delete samplePoints;
    return estimate;
}

//Transforms to Gaussian using Boxâ€“Muller
//For use in importance sampling
double estimateIntegralLambdaImp2D(double a, double b, double c, double d, int N, double lambda, function<double (double,double,double)> F, function<double** (int, double, double, double, double, mt19937 &)> sampleGen, mt19937 & gen) {
    double** samplePoints = sampleGen(N, 0, 1, 0, 1, gen);
    double temp;
    double temp2;
    //Transform to Gaussian
    for (int i = 0; i < N; i++) {
        temp = samplePoints[i][0];
        temp2 = samplePoints[i][1];
        samplePoints[i][0] = /*standardDeviation * */sqrt(-2*log(temp)) * cos(2 * M_PI * temp2) + mean;
        samplePoints[i][1] = /*standardDeviation * */sqrt(-2*log(temp)) * sin(2 * M_PI * temp2) + mean;
    }
    //Transform to interval
    for (int i = 0; i < N; i++) {
        samplePoints[i][0] = samplePoints[i][0] * (b-a) + a;
        samplePoints[i][1] = samplePoints[i][1] * (d-c) + c;
    }
    double estimate = 0;
    int numOut = 0;
    for (int i = 0; i < N; i++) {
        if (samplePoints[i][0] > a && samplePoints[i][0] < b && samplePoints[i][1] > c && samplePoints[i][1] < d) {
            temp = F(samplePoints[i][0],samplePoints[i][1],lambda);
            estimate += temp;
        } else {
            numOut++;
        }
    }
    if (numOut != N) {
        estimate /= (N-numOut);
    }
    estimate *= (b-a);
    for (int i = 0; i < N; i++) {
        delete samplePoints[i];
    }
    delete samplePoints;
    return estimate;
}

double* fourierCoefs1D(double a, double b, int N, int numTrials, double wStep, int numW, function<double* (int, double, double, mt19937 &)> sampleGen, mt19937 & gen) {
    double* samples;

    double* coefs = new double[numW];
    for (int i = 0; i < numW; i++) {
        coefs[i] = 0;
    }
    complex<double> temp(0,0);
    double tempAngle;
    for (int i = 0; i < numTrials; i++) {
        samples = sampleGen(N, a, b, gen);
        for (int w = 0; w < numW; w++) {
            temp = (0,0);
            for (int j = 0; j < N; j++) {
                temp += exp(-2 * M_PI * wStep * w * samples[j] * complex<double>(0,1));
            }
            coefs[w] += norm(temp) / (N * N * numTrials);
        }
    }
    return coefs;
}

double** fourierCoefs2D(double a, double b, double c, double d, int N, int numTrials, double wStep, int numW, function<double** (int, double, double, double, double, mt19937 &)> sampleGen, mt19937 & gen) {
    //Round N to close perfect square
    //N = sqrt(N);
    //N = N * N;
    
    double** samples;
    double** spectra = new double*[numW*2+1];
    for (int i = 0; i < numW*2+1; i++) {
        spectra[i] = new double[numW*2+1];
        for (int j = 0; j < numW*2+1; j++) {
            spectra[i][j] = 0;
        }
    }
    complex<double> temp(0,0);
    for (int i = 0; i < numTrials; i++) {
        samples = sampleGen(N, a, b, c, d, gen);
        for (int wX = -numW; wX <= numW; wX++) {
            for (int wY = -numW; wY <= numW; wY++) {
                temp = (0,0);
                for (int j = 0; j < N; j++) {
                    temp += exp(-2 * M_PI * wStep * (wX * samples[j][0] + wY * samples[j][1]) * complex<double>(0,1));
                }
                spectra[-wY + numW][wX + numW] += norm(temp) / (N * numTrials);//Each coefficient multiplied by sqrt(N) compared to regular (?) formula
            }
        }
        for (int i = 0; i < N; i++) {
            delete samples[i];
        }
        delete samples;
    }
    return spectra;
}

/**
 * Creates intensity strip images based on estimating the integral of a particular 1D function over the interval [0, 1]
 * testFunc is the function to approximate the integral of, and groundTruthFunc returns the correct value of the integral for a particular lambda
 * Lambda will range from 0 to 1, with numLambdas intermediate values tested, each corresponding to a particular column of the strips
 * numTrials trials will be done for each value of lambda, corresponding to the rows of the strips
 * A strip will be generated for ground truth, pure Monte Carlo (uniformly random sampling), uniform (sample points at the center of each strata),
 * and stratified/jittered (sample points at a random location within each strata)
 */
void makeIntensityStrips(int numLambdas, int numSamples, int numTrials, int imgWidth, int imgHeight, function<double (double,double)> testFunc, function<double (double)> groundTruthFunc, mt19937 & gen, string fileName) {
    double* samples;
    unsigned char image[imgHeight*imgWidth];
    for (int i = 0; i < imgHeight*imgWidth; i++) {
        image[i] = 255;
    }
    double temp;
    double minVal = 10000000000;
    double maxVal = -10000000000;
    for (double j = 0; j < numLambdas; j++) {
        temp = groundTruthFunc(j/numLambdas);
        if (temp < minVal) {
            minVal = temp;
        }
        if (temp > maxVal) {
            maxVal = temp;
        }
    }
    //Ground Truth
    for (int i = 0; i < 100; i++) {
        for (double j = 0; j < numLambdas; j++) {
            image[(unsigned int) (i*imgWidth + j + 20)] = (unsigned char) max(0.0, min(255.0, 30 + (180 / (maxVal - minVal)) * (groundTruthFunc(j/numLambdas) - minVal)));
            //cout << groundTruthFunc(j/numLambdas) << endl;
        }
    }
    cout << "ground truth done" << endl;
    //Monte Carlo
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(0, 1, numSamples, j/numLambdas, testFunc, genPureMonteCarlo1D, gen);
            image[(unsigned int) ((i + 110)*imgWidth + j + 20)] = (unsigned char) max(0.0, min(255.0, 30 + (180 / (maxVal - minVal)) * (temp - minVal)));
        }
    }
    cout << "pure monte done" << endl;
    //Uniform
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(0, 1, numSamples, j/numLambdas, testFunc, genUniform1D, gen);
            image[(unsigned int) ((i + 220)*imgWidth + j + 20)] = (unsigned char) max(0.0, min(255.0, 30 + (180 / (maxVal - minVal)) * (temp - minVal)));
        }
    }
    //Stratified
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(0, 1, numSamples, j/numLambdas, testFunc, genStratified1D, gen);
            image[(unsigned int) ((i + 330)*imgWidth + j + 20)] = (unsigned char) max(0.0, min(255.0, 30 + (180 / (maxVal - minVal)) * (temp - minVal)));
        }
    }
    //Halton (Since it's 1D this is a.k.a. van der Corput)
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(0, 1, numSamples, j/numLambdas, testFunc, genHaltonSeq1D, gen);
            image[(unsigned int) ((i + 440)*imgWidth + j + 20)] = (unsigned char) max(0.0, min(255.0, 30 + (180 / (maxVal - minVal)) * (temp - minVal)));
        }
    }
    //Antithetic Monte Carlo
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(0, 1, numSamples, j/numLambdas, testFunc, genAntitheticMonteCarlo1D, gen);
            image[(unsigned int) ((i + 550)*imgWidth + j + 20)] = (unsigned char) max(0.0, min(255.0, 30 + (180 / (maxVal - minVal)) * (temp - minVal)));
        }
    }
    //Make image file
    ofstream ofs(fileName, ios::out | ios::binary);
    ofs << "P6\n" << imgWidth << " " << imgHeight << "\n255\n"; 
    for (int i = 0; i < imgWidth * imgHeight; ++i) { 
        ofs << image[i] << image[i] << image[i];
    } 
    ofs.close();
}

/**
 * Prints the RMSE from estimating the integral of a particular 1D function over the interval [0, 1]
 * testFunc is the function to approximate the integral of, and groundTruthFunc returns the correct value of the integral for a particular lambda
 * Lambda will range from 0 to 1, with numLambdas intermediate values tested
 * numTrials trials will be done for each value of lambda
 * RMSE will be calculated for pure Monte Carlo (uniformly random sampling), uniform (sample points at the center of each strata),
 * and stratified/jittered (sample points at a random location within each strata)
 */
void printRMSE1D(int numLambdas, int numSamples, int numTrials, function<double (double,double)> testFunc, function<double (double, double, double)> groundTruthFunc, mt19937 & gen, double intervalStart, double intervalEnd) {
    double avgError = 0;
    double temp;
    
    cout << "Monte Carlo:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genPureMonteCarlo1D, gen);
            avgError += (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd));
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Antithetic Monte Carlo:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genAntitheticMonteCarlo1D, gen);
            avgError += (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd));
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Uniform:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genUniform1D, gen);
            avgError += (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd));
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Stratified:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genStratified1D, gen);
            avgError += (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd));
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Stratified (antithetic):\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genStratifiedAntithetic1D, gen);
            avgError += (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd));
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Halton:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genHaltonSeq1D, gen);
            avgError += (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd));
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Halton (rotated):\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genHaltonSeqRot1D, gen);
            avgError += (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd));
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Halton (antithetic):\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genHaltonSeqAntithetic1D, gen);
            avgError += (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd));
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Simpson's Rule:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegralSimpsons1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, gen);
            avgError += (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd));
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Adaptive Polynomial Approximation:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            temp = estimateIntegralPolyApprox(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, gen);
            //temp = estimateIntegralSimpsons1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, gen);
            avgError += (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, intervalStart, intervalEnd));
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas)) << endl << endl;
}

/**
 * Prints the RMSE from estimating the integral of a particular 1D function over the interval [0, 1]
 * testFunc is the function to approximate the integral of, and groundTruthFunc returns the correct value of the integral for a particular lambda
 * Lambda will range from 0 to 1, with numLambdas intermediate values tested
 * numTrials trials will be done for each value of lambda
 * RMSE will be calculated for pure Monte Carlo (uniformly random sampling), uniform (sample points at the center of each strata),
 * and stratified/jittered (sample points at a random location within each strata)
 */
void printRMSE2Lambdas1D(int numLambdas, int numSamples, int numTrials, function<double (double,double,double)> testFunc, function<double (double, double, double, double)> groundTruthFunc, mt19937 & gen, double intervalStart, double intervalEnd) {
    double avgError = 0;
    double temp;
    
    cout << "Monte Carlo:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genPureMonteCarlo1D, gen);
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Antithetic Monte Carlo:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genAntitheticMonteCarlo1D, gen);
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Uniform:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genUniform1D, gen);
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Uniform Jitter:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genUniformJitter1D, gen);
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Stratified:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genStratified1D, gen);
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Stratified (antithetic):\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genStratifiedAntithetic1D, gen);
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Halton:\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genHaltonSeq1D, gen);
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Halton (rotated):\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genHaltonSeqRot1D, gen);
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Halton (antithetic):\n";
    for (int i = 0; i < numTrials; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genHaltonSeqAntithetic1D, gen);
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials*numLambdas*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Simpson's Rule:\n";
    for (int i = 0; i < 1; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegralSimpsons2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, gen);
                if ((temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) > 0.0002) {
                    cout << j/numLambdas << ", " << k/numLambdas << endl;
                    cout << (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) << endl;
                }
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numLambdas*numLambdas)) << endl << endl;
    avgError = 0;
    cout << "Polynomial Approximation (non adaptive):\n";
    for (int i = 0; i < 1; i++) {
        for (double j = 0; j < numLambdas; j++) {
            for (double k = 0; k < numLambdas; k++) {
                temp = estimateIntegralPolyApprox2Lambdas(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, gen);
                if ((temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) > 0.0002) {
                    cout << j/numLambdas << ", " << k/numLambdas << endl;
                    cout << (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) << endl;
                }
                avgError += (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd)) * (temp-groundTruthFunc(j/numLambdas, k/numLambdas, intervalStart, intervalEnd));
            }
        }
    }
    cout << "RMSE: " << sqrt(avgError/(numLambdas*numLambdas)) << endl << endl;
}

/**
 * Prints the variance from estimating the integral of a particular 1D function over the interval [0, 1]
 * testFunc is the function to approximate the integral of, and groundTruthFunc returns the correct value of the integral for a particular lambda
 * Lambda will range from 0 to 1, with numLambdas intermediate values tested
 * numTrials trials will be done for each value of lambda
 * Variance will be calculated for pure Monte Carlo (uniformly random sampling),
 * antithetic Monte Carlo (points generated in pairs as x and 1-x, where x is generated uniformly randomly)
 * uniform (sample points at the center of each strata),
 * and stratified/jittered (sample points at a random location within each strata)
 */
void printVariance1D(int numLambdas, int numSamples, int numTrials, function<double (double,double)> testFunc, mt19937 & gen, double intervalStart, double intervalEnd) {
    double avgVar = 0;
    double tempVar = 0;
    double avgEst = 0;
    double ests[numTrials];
    double temp;
    cout << "Pure Monte Carlo:\n";
    for (double j = 0; j < numLambdas; j++) {
        tempVar = 0;
        avgEst = 0;
        for (int i = 0; i < numTrials; i++) {
            ests[i] = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genPureMonteCarlo1D, gen);
            avgEst += ests[i];
        }
        avgEst /= numTrials;
        for (int i = 0; i < numTrials; i++) {
            tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
        }
        avgVar += tempVar/(numTrials - 1);
    }
    cout << "Variance: " << avgVar/numLambdas << endl << endl;
    avgVar = 0;
    cout << "Antithetic Monte Carlo:\n";
    for (double j = 0; j < numLambdas; j++) {
        tempVar = 0;
        avgEst = 0;
        for (int i = 0; i < numTrials; i++) {
            ests[i] = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genAntitheticMonteCarlo1D, gen);
            avgEst += ests[i];
        }
        avgEst /= numTrials;
        for (int i = 0; i < numTrials; i++) {
            tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
        }
        avgVar += tempVar/(numTrials - 1);
    }
    cout << "Variance: " << avgVar/numLambdas << endl << endl;
    avgVar = 0;
    cout << "Uniform:\n";
    for (double j = 0; j < numLambdas; j++) {
        tempVar = 0;
        avgEst = 0;
        for (int i = 0; i < numTrials; i++) {
            ests[i] = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genUniform1D, gen);
            avgEst += ests[i];
        }
        avgEst /= numTrials;
        for (int i = 0; i < numTrials; i++) {
            tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
        }
        avgVar += tempVar/(numTrials - 1);
    }
    cout << "Variance: " << avgVar/numLambdas << endl << endl;
    avgVar = 0;
    cout << "Stratified:\n";
    for (double j = 0; j < numLambdas; j++) {
        tempVar = 0;
        avgEst = 0;
        for (int i = 0; i < numTrials; i++) {
            ests[i] = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genStratified1D, gen);
            avgEst += ests[i];
        }
        avgEst /= numTrials;
        for (int i = 0; i < numTrials; i++) {
            tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
        }
        avgVar += tempVar/(numTrials - 1);
    }
    cout << "Variance: " << avgVar/numLambdas << endl << endl;
    avgVar = 0;
    cout << "Stratified (antithetic):\n";
    for (double j = 0; j < numLambdas; j++) {
        tempVar = 0;
        avgEst = 0;
        for (int i = 0; i < numTrials; i++) {
            ests[i] = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genStratifiedAntithetic1D, gen);
            avgEst += ests[i];
        }
        avgEst /= numTrials;
        for (int i = 0; i < numTrials; i++) {
            tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
        }
        avgVar += tempVar/(numTrials - 1);
    }
    cout << "Variance: " << avgVar/numLambdas << endl << endl;
    avgVar = 0;
    cout << "Halton:\n";
    for (double j = 0; j < numLambdas; j++) {
        tempVar = 0;
        avgEst = 0;
        for (int i = 0; i < numTrials; i++) {
            ests[i] = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genHaltonSeq1D, gen);
            avgEst += ests[i];
        }
        avgEst /= numTrials;
        for (int i = 0; i < numTrials; i++) {
            tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
        }
        avgVar += tempVar/(numTrials - 1);
    }
    cout << "Variance: " << avgVar/numLambdas << endl << endl;
    avgVar = 0;
    cout << "Halton (rotated):\n";
    for (double j = 0; j < numLambdas; j++) {
        tempVar = 0;
        avgEst = 0;
        for (int i = 0; i < numTrials; i++) {
            ests[i] = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genHaltonSeqRot1D, gen);
            avgEst += ests[i];
        }
        avgEst /= numTrials;
        for (int i = 0; i < numTrials; i++) {
            tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
        }
        avgVar += tempVar/(numTrials - 1);
    }
    cout << "Variance: " << avgVar/numLambdas << endl << endl;
    avgVar = 0;
    cout << "Halton (antithetic):\n";
    for (double j = 0; j < numLambdas; j++) {
        tempVar = 0;
        avgEst = 0;
        for (int i = 0; i < numTrials; i++) {
            ests[i] = estimateIntegral1D(intervalStart, intervalEnd, numSamples, j/numLambdas, testFunc, genHaltonSeqAntithetic1D, gen);
            avgEst += ests[i];
        }
        avgEst /= numTrials;
        for (int i = 0; i < numTrials; i++) {
            tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
        }
        avgVar += tempVar/(numTrials - 1);
    }
    cout << "Variance: " << avgVar/numLambdas << endl << endl;
}

/**
 * Prints the variance from estimating the integral of a particular 1D function over the interval [0, 1]
 * testFunc is the function to approximate the integral of, and groundTruthFunc returns the correct value of the integral for a particular lambda
 * Lambda will range from 0 to 1, with numLambdas intermediate values tested
 * numTrials trials will be done for each value of lambda
 * Variance will be calculated for pure Monte Carlo (uniformly random sampling),
 * antithetic Monte Carlo (points generated in pairs as x and 1-x, where x is generated uniformly randomly)
 * uniform (sample points at the center of each strata),
 * and stratified/jittered (sample points at a random location within each strata)
 */
void printVariance2Lambdas1D(int numLambdas, int numSamples, int numTrials, function<double (double,double,double)> testFunc, mt19937 & gen, double intervalStart, double intervalEnd) {
    double avgVar = 0;
    double tempVar = 0;
    double avgEst = 0;
    double ests[numTrials];
    double temp;
    cout << "Pure Monte Carlo:\n";
    for (double j = 0; j < numLambdas; j++) {
        for (double k = 0; k < numLambdas; k++) {
            tempVar = 0;
            avgEst = 0;
            for (int i = 0; i < numTrials; i++) {
                ests[i] = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genPureMonteCarlo1D, gen);
                avgEst += ests[i];
            }
            avgEst /= numTrials;
            for (int i = 0; i < numTrials; i++) {
                tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
            }
            avgVar += tempVar/(numTrials - 1);
        }
    }
    cout << "Variance: " << avgVar/(numLambdas*numLambdas) << endl << endl;
    avgVar = 0;
    cout << "Antithetic Monte Carlo:\n";
    for (double j = 0; j < numLambdas; j++) {
        for (double k = 0; k < numLambdas; k++) {
            tempVar = 0;
            avgEst = 0;
            for (int i = 0; i < numTrials; i++) {
                ests[i] = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genAntitheticMonteCarlo1D, gen);
                avgEst += ests[i];
            }
            avgEst /= numTrials;
            for (int i = 0; i < numTrials; i++) {
                tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
            }
            avgVar += tempVar/(numTrials - 1);
        }
    }
    cout << "Variance: " << avgVar/(numLambdas*numLambdas) << endl << endl;
    avgVar = 0;
    cout << "Uniform:\n";
    for (double j = 0; j < numLambdas; j++) {
        for (double k = 0; k < numLambdas; k++) {
            tempVar = 0;
            avgEst = 0;
            for (int i = 0; i < numTrials; i++) {
                ests[i] = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genUniform1D, gen);
                avgEst += ests[i];
            }
            avgEst /= numTrials;
            for (int i = 0; i < numTrials; i++) {
                tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
            }
            avgVar += tempVar/(numTrials - 1);
        }
    }
    cout << "Variance: " << avgVar/(numLambdas*numLambdas) << endl << endl;
    avgVar = 0;
    cout << "Stratified:\n";
    for (double j = 0; j < numLambdas; j++) {
        for (double k = 0; k < numLambdas; k++) {
            tempVar = 0;
            avgEst = 0;
            for (int i = 0; i < numTrials; i++) {
                ests[i] = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genStratified1D, gen);
                avgEst += ests[i];
            }
            avgEst /= numTrials;
            for (int i = 0; i < numTrials; i++) {
                tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
            }
            avgVar += tempVar/(numTrials - 1);
        }
    }
    cout << "Variance: " << avgVar/(numLambdas*numLambdas) << endl << endl;
    avgVar = 0;
    cout << "Stratified (antithetic):\n";
    for (double j = 0; j < numLambdas; j++) {
        for (double k = 0; k < numLambdas; k++) {
            tempVar = 0;
            avgEst = 0;
            for (int i = 0; i < numTrials; i++) {
                ests[i] = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genStratifiedAntithetic1D, gen);
                avgEst += ests[i];
            }
            avgEst /= numTrials;
            for (int i = 0; i < numTrials; i++) {
                tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
            }
            avgVar += tempVar/(numTrials - 1);
        }
    }
    cout << "Variance: " << avgVar/(numLambdas*numLambdas) << endl << endl;
    avgVar = 0;
    cout << "Halton:\n";
    for (double j = 0; j < numLambdas; j++) {
        for (double k = 0; k < numLambdas; k++) {
            tempVar = 0;
            avgEst = 0;
            for (int i = 0; i < numTrials; i++) {
                ests[i] = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genHaltonSeq1D, gen);
                avgEst += ests[i];
            }
            avgEst /= numTrials;
            for (int i = 0; i < numTrials; i++) {
                tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
            }
            avgVar += tempVar/(numTrials - 1);
        }
    }
    cout << "Variance: " << avgVar/(numLambdas*numLambdas) << endl << endl;
    avgVar = 0;
    cout << "Halton (rotated):\n";
    for (double j = 0; j < numLambdas; j++) {
        for (double k = 0; k < numLambdas; k++) {
            tempVar = 0;
            avgEst = 0;
            for (int i = 0; i < numTrials; i++) {
                ests[i] = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genHaltonSeqRot1D, gen);
                avgEst += ests[i];
            }
            avgEst /= numTrials;
            for (int i = 0; i < numTrials; i++) {
                tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
            }
            avgVar += tempVar/(numTrials - 1);
        }
    }
    cout << "Variance: " << avgVar/(numLambdas*numLambdas) << endl << endl;
    avgVar = 0;
    cout << "Halton (antithetic):\n";
    for (double j = 0; j < numLambdas; j++) {
        for (double k = 0; k < numLambdas; k++) {
            tempVar = 0;
            avgEst = 0;
            for (int i = 0; i < numTrials; i++) {
                ests[i] = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, numSamples, j/numLambdas, k/numLambdas, testFunc, genHaltonSeqAntithetic1D, gen);
                avgEst += ests[i];
            }
            avgEst /= numTrials;
            for (int i = 0; i < numTrials; i++) {
                tempVar += (ests[i]-avgEst) * (ests[i]-avgEst);
            }
            avgVar += tempVar/(numTrials - 1);
        }
    }
    cout << "Variance: " << avgVar/(numLambdas*numLambdas) << endl << endl;
}

/**
 * Prints the RMSE from estimating the integral of a particular 2D function over the interval x in [0, 1], y in [0, 1]
 * testFunc is the function to approximate the integral of, and groundTruth is the correct value for the integral
 * numTrials trials will be done for each value of lambda
 * RMSE will be calculated for pure Monte Carlo (uniformly random sampling), uniform (sample points at the center of each strata),
 * and stratified/jittered (sample points at a random location within each strata)
 */
void printRMSE2D(int numSamples, int numTrials, function<double (double,double)> testFunc, double groundTruth, mt19937 & gen) {
    double avgError = 0;
    double temp;
    cout << "Monte Carlo:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genPureMonteCarlo2D, gen);
        avgError += (temp-groundTruth) * (temp-groundTruth);
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials)) << endl << endl;
    avgError = 0;
    cout << "Uniform:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genUniform2D, gen);
        avgError += (temp-groundTruth) * (temp-groundTruth);
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials)) << endl << endl;
    avgError = 0;
    cout << "Stratified:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genStratified2D, gen);
        avgError += (temp-groundTruth) * (temp-groundTruth);
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials)) << endl << endl;
    avgError = 0;
    cout << "N-Rooks:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genNRooks2D, gen);
        avgError += (temp-groundTruth) * (temp-groundTruth);
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials)) << endl << endl;
    avgError = 0;
    cout << "Multi-Jitter:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genMultiJitter2D, gen);
        avgError += (temp-groundTruth) * (temp-groundTruth);
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials)) << endl << endl;
    avgError = 0;
    cout << "Halton:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genHaltonSeq2D, gen);
        avgError += (temp-groundTruth) * (temp-groundTruth);
    }
    cout << "RMSE: " << sqrt(avgError/(numTrials)) << endl << endl;
}

/**
 * Prints the average error (not RMSE) from estimating the integral of a particular 2D function over the interval x in [0, 1], y in [0, 1]
 * testFunc is the function to approximate the integral of, and groundTruth is the correct value for the integral
 * numTrials trials will be done for each value of lambda
 * Error will be calculated for pure Monte Carlo (uniformly random sampling), uniform (sample points at the center of each strata),
 * and stratified/jittered (sample points at a random location within each strata)
 */
void printError2D(int numSamples, int numTrials, function<double (double,double)> testFunc, double groundTruth, mt19937 & gen) {
    //Mostly to recreate https://www.semanticscholar.org/paper/Progressive-Multi-Jittered-Sample-Sequences-%3A-Christensen-Kensler/c19a94e814c8bd56a12ee108daacd9c243c2b7ef/figure/1
    double avgError = 0;
    double temp;
    cout << "Monte Carlo:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genPureMonteCarlo2D, gen);
        avgError += abs(temp-groundTruth);
    }
    cout << "Average Error: " << avgError/(numTrials) << endl << endl;
    avgError = 0;
    cout << "Uniform:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genUniform2D, gen);
        avgError += abs(temp-groundTruth);
    }
    cout << "RMSE: " << avgError/(numTrials) << endl << endl;
    avgError = 0;
    cout << "Stratified:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genStratified2D, gen);
        avgError += abs(temp-groundTruth);
    }
    cout << "RMSE: " << avgError/(numTrials) << endl << endl;
    avgError = 0;
    cout << "N-Rooks:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genNRooks2D, gen);
        avgError += abs(temp-groundTruth);
    }
    cout << "RMSE: " << avgError/(numTrials) << endl << endl;
    avgError = 0;
    cout << "Multi-Jitter:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genMultiJitter2D, gen);
        avgError += abs(temp-groundTruth);
    }
    cout << "RMSE: " << avgError/(numTrials) << endl << endl;
    avgError = 0;
    cout << "Halton:\n";
    for (int i = 0; i < numTrials; i++) {
        temp = estimateIntegral2D(0, 1, 0, 1, numSamples, testFunc, genHaltonSeqRot2D, gen);
        avgError += abs(temp-groundTruth);
    }
    cout << "RMSE: " << avgError/(numTrials) << endl << endl;
}

void makePowerSpectra(int numSamples, int numTrials, int imgWidth, int imgHeight, int maxW, function<double** (int, double, double, double, double, mt19937 &)> sampleGen, mt19937 & gen, string fileName) {
    unsigned char image[imgHeight*imgWidth];
    for (int i = 0; i < imgHeight*imgWidth; i++) {
        image[i] = 255;
    }

    double** testSpectra = fourierCoefs2D(0, 1, 0, 1, numSamples, numTrials, 1, maxW, sampleGen, gen);
    for (int i = 0; i < maxW * 2 + 1; i++) {
        for (int j = 0; j < maxW * 2 + 1; j++) {
            image[i * imgWidth + j] = (unsigned char) min(255, (int) (200 * testSpectra[i][j]));
        }
    }
    for (int i = 0; i < maxW * 2 + 1; i++) {
        delete testSpectra[i];
    }
    delete testSpectra;

    //Make image file
    ofstream ofs(fileName, ios::out | ios::binary);
    ofs << "P6\n" << imgWidth << " " << imgHeight << "\n255\n"; 
    for (int i = 0; i < imgWidth * imgHeight; ++i) { 
        ofs << image[i] << image[i] << image[i];
    } 
    ofs.close();
}

void printConvergenceRates1D(int startN, int endN, int numLambdas, int numTrials, function<double (double,double)> testFunc, function<double (double, double, double)> groundTruthFunc, mt19937 & gen, double intervalStart, double intervalEnd) {
    double avgError = 0;
    double temp = 0;
    uniform_real_distribution<> dist(intervalStart, intervalEnd);
    double lambda1;
    ofstream ofs("conv.txt", ios::out);
    //ofs << "Number of samples,Pure Monte Carlo,Uniform,Stratified,Halton\n";
    for (int n = startN; n <= endN; n++) {
        ofs << n << ",";
        avgError = 0;
        //Monte Carlo
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genPureMonteCarlo1D, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
            //ofs << "trial done" << endl;
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Antithetic Monte Carlo
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genAntitheticMonteCarlo1D, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
            //ofs << "trial done" << endl;
        }
        //cout << temp << endl;
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Uniform
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genUniform1D, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        //cout << temp << endl;
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Uniform Jitter
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genUniformJitter1D, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Stratified
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genStratified1D, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Stratified (antithetic within strata)
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genStratifiedAntithetic1D, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Stratified (antithetic globally)
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genStratifiedAntithetic1D2, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Stratified (antithetic globally and locally)
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genStratifiedAntithetic1D3, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Halton
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genHaltonSeq1D, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Halton (rotated)
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genHaltonSeqRot1D, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Halton (antithetic)
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegral1D(intervalStart, intervalEnd, n, lambda1, testFunc, genHaltonSeqAntithetic1D, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Simpson's Rule
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegralSimpsons1D(intervalStart, intervalEnd, n, lambda1, testFunc, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        //Poly approx Rule
        avgError = 0;
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegralPolyApprox(intervalStart, intervalEnd, n, lambda1, testFunc, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        //Poly approx Rule w/ control variate (50% of samples to each)
        avgError = 0;
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegralPolyApproxControlVariate(intervalStart, intervalEnd, n, lambda1, testFunc, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        //Poly approx Rule (adaptive)
        avgError = 0;
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegralAdapPolyApprox(intervalStart, intervalEnd, n, lambda1, testFunc, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        //Poly approx Rule w/ control variate (adaptive)
        avgError = 0;
        for (int i = 0; i < numTrials; i++) {
            for (double j = intervalStart; j < intervalEnd; j += (intervalEnd - intervalStart)/numLambdas) {
                lambda1 = dist(gen);
                temp = estimateIntegralAdapPolyApproxControlVariate(intervalStart, intervalEnd, n, lambda1, testFunc, gen);
                avgError += (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, intervalStart, intervalEnd));
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << endl;
        cout << "n = " << n << " done" << endl;
    }
}

void printConvergenceRates1D2Lambdas(int startN, int endN, int numLambdas, int numTrials, function<double (double,double,double)> testFunc, function<double (double, double, double, double)> groundTruthFunc, mt19937 & gen, double intervalStart, double intervalEnd) {
    double avgError = 0;
    double temp;
    uniform_real_distribution<> dist(0,1);
    ofstream ofs("conv.txt", ios::out);
    double lambda1, lambda2;
    //ofs << "Number of samples,Pure Monte Carlo,Uniform,Stratified,Halton\n";
    for (int n = startN; n <= endN; n++) {
        ofs << n << ",";
        avgError = 0;
        //Monte Carlo
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genPureMonteCarlo1D, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas * numLambdas)) << ",";
        avgError = 0;
        //Antithetic Monte Carlo
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genAntitheticMonteCarlo1D, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas * numLambdas)) << ",";
        avgError = 0;
        //Uniform
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genUniform1D, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas * numLambdas)) << ",";
        avgError = 0;
        //Uniform Jitter
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genUniformJitter1D, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Stratified
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genStratified1D, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Stratified (antithetic within strata)
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genStratifiedAntithetic1D, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Stratified (antithetic globally)
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genStratifiedAntithetic1D2, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Stratified (antithetic globally and locally)
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genStratifiedAntithetic1D3, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Halton
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genHaltonSeq1D, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Halton (rotated)
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genHaltonSeqRot1D, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Halton (antithetic)
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegral2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, genHaltonSeqAntithetic1D, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Simpson's Rule
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegralSimpsons2Lambdas1D(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Polynomial Approximation
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegralPolyApprox2Lambdas(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Polynomial Approximation with control variate
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegralPolyApproxControlVariate2Lambdas(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Polynomial Approximation (adaptive)
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegralAdapPolyApprox2Lambdas(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << ",";
        avgError = 0;
        //Polynomial Approximation (adaptive) with control variate
        for (int i = 0; i < numTrials; i++) {
            for (double j = 0; j < numLambdas; j++) {
                for (double k = 0; k < numLambdas; k++) {
                    lambda1 = dist(gen);
                    lambda2 = dist(gen);
                    temp = estimateIntegralAdapPolyApproxControlVariate2Lambdas(intervalStart, intervalEnd, n, lambda1, lambda2, testFunc, gen);
                    avgError += (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd)) * (temp-groundTruthFunc(lambda1, lambda2, intervalStart, intervalEnd));
                }
            }
        }
        ofs << sqrt(avgError/(numTrials * numLambdas)) << endl;
        cout << "n = " << n << " done" << endl;
    }
}

//Tests perfect square between startN^2 and endN^2, inclusive
void printConvergenceRates2D(int startN, int endN, int numTrials, function<double (double,double)> testFunc, double groundTruth, mt19937 & gen) {
    double avgError = 0;
    double temp;
    int n;
    ofstream ofs("conv.txt", ios::out);
    //cout << "Number of samples,Pure Monte Carlo,Uniform,Stratified,Halton\n";
    for (int j = startN; j <= endN; j++) {
        n = j * j;
        ofs << n << ",";
        avgError = 0;
        //Monte Carlo
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genPureMonteCarlo2D, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/(numTrials) << ",";
        avgError = 0;
        //Monte Carlo w/ antithetic sampling
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genAntitheticMonteCarlo2D, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/(numTrials) << ",";
        avgError = 0;
        //Uniform
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genUniform2D, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/(numTrials) << ",";
        avgError = 0;
        //Uniform Jitter
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genUniformJitter2D, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/(numTrials) << ",";
        avgError = 0;
        //Stratified
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genStratified2D, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/(numTrials) << ",";
        avgError = 0;
        //Stratified (locally antithetic)
        int tempN = max(8, (int) (sqrt(n/2)) * (int) (sqrt(n/2)) * 2);//will repeat last even for odd ns
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, tempN, testFunc, genStratifiedAntithetic2D, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/(numTrials) << ",";
        avgError = 0;
        //Stratified (globally antithetic)
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genStratifiedAntithetic2D2, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/(numTrials) << ",";
        avgError = 0;
        //Stratified (locally and globally antithetic)
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, tempN, testFunc, genStratifiedAntithetic2D3, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/(numTrials) << ",";
        avgError = 0;
        //N-Rooks
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genNRooks2D, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/(numTrials) << ",";
        avgError = 0;
        //Multi-jitter
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genMultiJitter2D, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/(numTrials) << ",";
        avgError = 0;
        //Halton
        for (int i = 0; i < 1; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genHaltonSeq2D, gen);
            //cout << "error for n = " << n << " is " << abs(temp-groundTruth) << endl;
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError << ",";
        avgError = 0;
        //Halton antithetic
        for (int i = 0; i < 1; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genHaltonSeqAntithetic2D, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError << ",";
        avgError = 0;
        //Halton rotated
        for (int i = 0; i < numTrials; i++) {
            temp = estimateIntegral2D(0, 1, 0, 1, n, testFunc, genHaltonSeqRot2D, gen);
            avgError += abs(temp-groundTruth);
        }
        ofs << avgError/numTrials << endl;
        cout << "n = " << n << " done!\n";
    }
}

//Tests perfect square between startN^2 and endN^2, inclusive
//partway done
void printConvergenceRatesLambda2D(double a, double b, double c, double d, int startN, int endN, int numLambdas, int numTrials, function<double (double,double,double)> testFunc, function<double (double, double, double, double, double)> groundTruthFunc, mt19937 & gen) {
    double avgError = 0;
    double temp;
    int n;
    ofstream ofs("conv.txt", ios::out);
    //cout << "Number of samples,Pure Monte Carlo,Uniform,Stratified,Halton\n";
    for (int j = startN; j <= endN; j++) {
        n = j * j;
        ofs << n << ",";
        avgError = 0;
        //Monte Carlo
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genPureMonteCarlo2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Monte Carlo w/ antithetic sampling
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genAntitheticMonteCarlo2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Uniform
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genUniform2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Uniform Jitter
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genUniformJitter2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Stratified
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genStratified2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Stratified (locally antithetic)
        int tempN = max(8, (int) (sqrt(n/2)) * (int) (sqrt(n/2)) * 2);//will repeat last even for odd ns
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, tempN, k, testFunc, genStratifiedAntithetic2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Stratified (globally antithetic)
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genStratifiedAntithetic2D2, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Stratified (locally and globally antithetic)
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, tempN, k, testFunc, genStratifiedAntithetic2D3, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //N-Rooks
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genNRooks2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Multi-jitter
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genMultiJitter2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Halton
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genHaltonSeq2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Halton antithetic
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genHaltonSeqAntithetic2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Halton rotated
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambda2D(a, b, c, d, n, k, testFunc, genHaltonSeqRot2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << endl;
        cout << "n = " << n << " done!\n";
    }
}

void printConvergenceRatesLambdaImp2D(double a, double b, double c, double d, int startN, int endN, int numLambdas, int numTrials, function<double (double,double,double)> testFunc, function<double (double, double, double, double, double)> groundTruthFunc, mt19937 & gen) {
    double avgError = 0;
    double temp;
    int n;
    ofstream ofs("conv.txt", ios::out);
    //cout << "Number of samples,Pure Monte Carlo,Uniform,Stratified,Halton\n";
    for (int j = startN; j <= endN; j++) {
        n = j * j;
        ofs << n << ",";
        avgError = 0;
        //Monte Carlo
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genPureMonteCarlo2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Monte Carlo w/ antithetic sampling
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genAntitheticMonteCarlo2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Uniform
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genUniform2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Uniform Jitter
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genUniformJitter2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Stratified
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genStratified2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Stratified (locally antithetic)
        int tempN = max(8, (int) (sqrt(n/2)) * (int) (sqrt(n/2)) * 2);//will repeat last even for odd ns
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, tempN, k, testFunc, genStratifiedAntithetic2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Stratified (globally antithetic)
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genStratifiedAntithetic2D2, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Stratified (locally and globally antithetic)
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, tempN, k, testFunc, genStratifiedAntithetic2D3, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //N-Rooks
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genNRooks2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Multi-jitter
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genMultiJitter2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Halton
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genHaltonSeq2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Halton antithetic
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genHaltonSeqAntithetic2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << ",";
        avgError = 0;
        //Halton rotated
        for (int i = 0; i < numTrials; i++) {
            for (double k = a; k < b; k += (b-a)/numLambdas) {
                temp = estimateIntegralLambdaImp2D(a, b, c, d, n, k, testFunc, genHaltonSeqRot2D, gen);
                avgError += abs(temp-groundTruthFunc(a,b,c,d,k));
            }
        }
        ofs << avgError/(numTrials * numLambdas) << endl;
        cout << "n = " << n << " done!\n";
    }
}

void printPoints1D(int N, function<double* (int, double, double, mt19937 &)> sampleGen, mt19937 & gen) {
    ofstream ofs("points.txt", ios::out);
    //cout << "Number of samples,Pure Monte Carlo,Uniform,Stratified,Halton\n";
    double* points = sampleGen(N, 0, 1, gen);
    for (int i = 0; i < N; i++) {
        ofs << points[i] << ",1" << endl;
    }
    delete points;
}


void printPoints2D(int N, function<double** (int, double, double, double, double, mt19937 &)> sampleGen, mt19937 & gen) {
    ofstream ofs("points.txt", ios::out);
    //cout << "Number of samples,Pure Monte Carlo,Uniform,Stratified,Halton\n";
    double** points = sampleGen(N, 0, 1, 0, 1, gen);
    for (int i = 0; i < N; i++) {
        ofs << points[i][0] << "," << points[i][1] << endl;
    }
    delete points;
}

double foo(double x, double lambda) {
    //printf("%b\n",1.0 + x*x);
    //cout << (1.0 + x*x) << endl;
    /*double d = 4 / (1 + x*x);
    unsigned char *p = (unsigned char *)&d;
    int i;
    for (i = 0; i < sizeof d; i++)
        printf("%02x ", p[i]);*/

    return 4 / (1 + x*x);
}

void importanceSamplingDemo(mt19937 & gen) {
    //Importance sampling demo
    uniform_real_distribution<> dist(0,1);
    double avg = 0;
    double avgError = 0;

    avgError = 0;
    for (int j = 0; j < 100; j++) {
        avg = 0;
        for (int i = 0; i < 1000; i++) {
            double x = dist(gen);
            double u = log((exp(1) - 1) * x + 1);
            avg += (exp(1) - 1) * u * u;
        }

        avg /= 1000;
        avgError += (avg - exp(1) + 2);
        //cout << avg << endl;
    }
    cout << avgError << endl;


    avgError = 0;
    for (int j = 0; j < 100; j++) {
        avg = 0;
        for (int i = 0; i < 1000; i++) {
            double x = dist(gen);
            avg += exp(x) * x * x;
        }

        avg /= 1000;
        avgError += (avg - exp(1) + 2);
        //cout << avg << endl;
    }
    cout << avgError << endl;
}

int main(int argc, char** argv) {
    cout.precision(12);
    string fileName = argv[1];
    random_device r;
    mt19937 gen(r());
    //cout << "Hmmm\n";
    int imgWidth = 500;
    int imgHeight = 700;
    int numSamples = 50;
    int numTrials = 500;
    int numLambdas = 10;
    double avgError = 0;
    double avgError2 = 0;
    double temp;

    const double groundTruthDisk = 0.5;
    const double groundTruthTriangle = 0.5;
    const double groundTruthStep2D = 1/M_PI;
    const double groundTruthGaussian = 0.55774628535;
    const double groundTruthBilinear = 0.25;
    const double groundTruthGausWRTStd2D = 0.2830050407186509;//for 0 to 1 and 0 to 1. temp. TODO: change

    //cout << foo(1/8.0,0) << endl;
    //cout << estimateIntegralSimpsons1D(0,1,9,0,foo,gen);
    //cout << estimateIntegral2D(-8,8,-8,8,81000000,gausWRTStd2D,genStratified2D,gen) << endl;
    //makeIntensityStrips(numLambdas,numSamples,numTrials,imgWidth,imgHeight,gaussianDerivativeWRTMean1D,groundTruthGaussianDerivativeWRTMean1D,gen,fileName);
    //printRMSE2Lambdas1D(numLambdas,numSamples,numTrials,gaussianDerivativeWRTMeanTimesStep1D,groundTruthGaussianDerivativeWRTMeanTimesStep1D,gen,-8,8);
    //printVariance2Lambdas1D(numLambdas,numSamples,numTrials,gaussianDerivativeWRTMeanTimesStep1D,gen,0,1);
    //cout << "So far so good????\n";
    //printRMSE1D2Lambdas(1,10,1000000,tempFoo,tempFooGroundTruth,gen,0,1);
    //makePowerSpectra(numSamples,numTrials,imgWidth,imgHeight,60,genHaltonSeq2D,gen,"test2.ppm");
    //radicalInverse(3,7);
    //printPoints1D(numSamples, genUniformJitter1D,gen);
    //cout << groundTruthGaussianDerivativeWRTMean1D(0,0,1) << endl;
    //cout << gaussianDerivativeWRTMean1D(0,1) << endl;
    printConvergenceRates1D2Lambdas(6,200,numLambdas,numTrials,gaussianDerivativeWRTMeanTimesStep1D,groundTruthGaussianDerivativeWRTMeanTimesStep1D,gen,-8,8);
    //printConvergenceRates1D(6,35,numLambdas,numTrials,gaussianDerivativeWRTMean1D,groundTruthGaussianDerivativeWRTMean1D,gen,-6,6);
    //printConvergenceRatesLambdaImp2D(0,1,0,1,2,40,numLambdas,numTrials,gausWRTMeanImp2D,gausWRTMeanImp2DGroundTruth,gen);
    //printPoints2D(50,genAntitheticMonteCarlo2D,gen);
    
}
